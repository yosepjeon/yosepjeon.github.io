+++
title = "DB 모델링 1"
date = "2024-03-21"
author = "Yosep"
tags = ["db", "modeling"]
description = "DB 모델링에 대해 학습 및 정리합니다."
weight = 3
+++

# DB 모델링 (Database Modeling)

## 1. DB 모델링이란?

**DB 모델링**은 현실 세계의 데이터를 데이터베이스에 저장하기 위해 구조화하는 과정이다.

비즈니스 요구사항을 분석하여 데이터의 구조, 관계, 제약조건을 정의하고, 이를 데이터베이스 스키마로 변환하는 작업을 말한다.

```
현실 세계 → 개념적 모델 → 논리적 모델 → 물리적 모델 → 실제 DB
```

---

## 2. DB 모델링의 3단계

### 2.1 개념적 모델링 (Conceptual Modeling)
- **목적**: 비즈니스 관점에서 데이터의 전체적인 구조 파악
- **산출물**: ERD (Entity-Relationship Diagram)
- **특징**:
  - DBMS 독립적
  - 엔티티(Entity), 속성(Attribute), 관계(Relationship) 정의
  - 비개발자도 이해 가능한 수준

### 2.2 논리적 모델링 (Logical Modeling)
- **목적**: 개념적 모델을 특정 데이터 모델로 변환
- **산출물**: 정규화된 테이블 구조
- **특징**:
  - 관계형 모델의 경우 테이블, 컬럼, PK, FK 정의
  - 정규화 수행
  - 여전히 DBMS 독립적

### 2.3 물리적 모델링 (Physical Modeling)
- **목적**: 실제 DBMS에 구현 가능한 형태로 변환
- **산출물**: DDL 스크립트
- **특징**:
  - 특정 DBMS에 종속적
  - 인덱스, 파티션, 저장공간 등 고려
  - 성능 최적화 반영

### 2.4 간단 예시 (개념 → 논리 → 물리)
```
[개념]
회원 - 주문 - 상품

[논리]
회원(member_id PK, name, email)
주문(order_id PK, member_id FK, ordered_at)
주문상세(order_id FK, product_id FK, qty, PK(order_id, product_id))
상품(product_id PK, name, price)

[물리] (MySQL 예시)
member.member_id BIGINT UNSIGNED
member.email VARCHAR(255) UNIQUE NOT NULL
orders.ordered_at DATETIME NOT NULL
order_item.qty INT UNSIGNED NOT NULL
product.price DECIMAL(10,2) NOT NULL
```

---

## 3. 좋은 DB 모델링의 조건

### 3.1 데이터 무결성 (Data Integrity)
- 엔티티 무결성: 모든 테이블은 PK를 가져야 함
- 참조 무결성: FK는 존재하는 PK/UK를 참조하고 삭제/갱신 규칙이 정의됨
- 도메인 무결성: 컬럼 값은 정의된 도메인 범위 내
- 제약 조건: NOT NULL, UNIQUE, CHECK, DEFAULT로 업무 규칙을 강제

### 3.2 데이터 중복 최소화
- 동일한 데이터가 여러 곳에 저장되지 않도록 함
- 정규화를 통해 이상현상(Anomaly) 방지

### 3.3 유연성과 확장성
- 요구사항 변경에 대응 가능한 구조
- 새로운 데이터 추가가 용이한 설계

### 3.4 성능 고려
- 자주 사용되는 쿼리에 최적화된 구조
- 적절한 반정규화 적용
- 인덱스/파티션/캐시 전략을 조회 패턴에 맞춤

### 3.5 명확한 명명 규칙
- 테이블은 단수형 명사, 컬럼은 의미 있는 이름 사용
- 키는 *_id, 날짜는 *_at 등 일관된 접미사 사용
- 예약어/모호한 축약어는 지양
```sql
-- 좋은 예
CREATE TABLE member (
    member_id BIGINT PRIMARY KEY,
    member_name VARCHAR(100),
    created_at TIMESTAMP
);

-- 나쁜 예
CREATE TABLE tbl1 (
    id INT PRIMARY KEY,
    nm VARCHAR(100),
    dt TIMESTAMP
);
```

### 3.6 키 설계 원칙
- 자연키 vs 대리키: 변경 가능성이 높으면 대리키 사용
- 복합키: 관계 의미를 명확히 하지만 FK가 복잡해질 수 있음
- 비즈니스 키는 UNIQUE로 보장하고 FK 인덱스도 함께 고려

---

## 4. 주요 방법론

### 4.1 정규화 (Normalization)

데이터 중복을 제거하고 이상현상을 방지하는 과정  
함수 종속(Functional Dependency)을 기준으로 테이블을 분해한다.

| 정규형 | 조건 |
|--------|------|
| **1NF** | 원자값만 포함 (반복 그룹 제거) |
| **2NF** | 1NF + 부분 함수 종속 제거 |
| **3NF** | 2NF + 이행 함수 종속 제거 |
| **BCNF** | 모든 결정자가 후보키 |

이상현상(Anomaly):
- 삽입 이상
- 갱신 이상
- 삭제 이상

고급 정규형(4NF/5NF)은 다치/조인 종속이 있을 때 고려한다.

```
예시: 주문 테이블 정규화

[비정규형]
주문(주문번호, 고객명, 고객주소, 상품1, 수량1, 상품2, 수량2...)

[1NF] - 반복 그룹 제거
주문(주문번호, 고객명, 고객주소, 상품명, 수량)

[2NF] - 부분 종속 제거
주문(주문번호, 고객ID)
고객(고객ID, 고객명, 고객주소)
주문상세(주문번호, 상품ID, 수량)

[3NF] - 이행 종속 제거
(필요시 추가 분리)
```

### 4.2 반정규화 (Denormalization)

성능 향상을 위해 의도적으로 중복을 허용하는 기법

```
사용 시점:
- 조인이 너무 많아 성능 저하 발생
- 읽기 작업이 쓰기보다 훨씬 많은 경우
- 실시간 집계가 필요한 경우

기법:
- 테이블 병합
- 컬럼 중복 (자주 조회되는 컬럼)
- 파생 컬럼 추가 (계산된 값 저장)
- 테이블 분할 (수직/수평)

주의사항:
- 쓰기 비용 증가 및 정합성 유지 비용 발생
- 변경이 잦은 컬럼은 중복을 지양
```

### 4.3 ER 모델링 (Entity-Relationship Modeling)

Peter Chen이 제안한 전통적인 방법론

```
구성요소:
┌─────────────┐     ┌─────────────┐
│   Entity    │───관계───│   Entity│
│  (테이블)     │     │  (테이블)    │
└─────────────┘     └─────────────┘
      │
   Attribute
   (컬럼)

관계 유형:
- 1:1 (일대일)
- 1:N (일대다)  ← 가장 일반적
- M:N (다대다) → 중간 테이블로 분해
```

관계는 카디널리티(1:1/1:N/M:N)와 선택성(필수/선택)을 함께 정의한다.

### 4.4 IE 표기법 (Information Engineering)

까마귀발(Crow's Foot) 표기법이라고도 함

```
기호:
──────┤     1 (하나)
──────<     N (다수)
────○┤     0 또는 1 (선택적)
────○<     0 이상 (선택적 다수)

예시:
[회원] ────○<──────┤ [주문]
 회원은 0개 이상의 주문을 가짐
 주문은 반드시 1명의 회원에 속함
```

IE 표기법은 카디널리티와 옵셔널리티를 동시에 표현하기 좋아 실무에서 자주 사용된다.

### 4.5 차원 모델링 (Dimensional Modeling)

데이터 웨어하우스/분석용 설계 방법

```
구성요소:
- Fact Table: 측정값, 수치 데이터 (매출액, 수량 등)
- Dimension Table: 분석 기준 (시간, 지역, 상품 등)

스키마 유형:

[Star Schema]
        ┌──────────┐
        │ 시간 Dim  │
        └────┬─────┘
             │
┌──────────┐ │ ┌──────────┐
│ 상품 Dim  ├─┼─┤ 지역 Dim  │
└──────────┘ │ └──────────┘
             │
        ┌────┴─────┐
        │ Fact     │
        │ (매출)    │
        └──────────┘

[Snowflake Schema]
- 차원 테이블을 정규화하여 확장
- Star보다 복잡하지만 저장공간 효율적

추가 고려:
- Slowly Changing Dimension(SCD): 이력 관리 방식(Type 1/2/3)
```

---

## 5. 실무 적용 가이드

### 5.1 설계 순서
```
1. 요구사항 분석
   └─ 업무 파악, 데이터 흐름 이해

2. 업무 규칙/제약 정리
   └─ 유일성, 필수값, 상태 전이, 값 범위

3. 엔티티 도출
   └─ 명사 추출, 핵심 개체 식별

4. 관계 정의
   └─ 엔티티 간 연관성 파악

5. 속성 정의
   └─ 각 엔티티의 세부 항목 정의

6. 식별자 지정
   └─ PK, UK, FK 결정

7. 정규화
   └─ 이상현상 제거

8. 조회/쓰기 패턴 검토
   └─ 주요 쿼리, 트래픽, SLA 확인

9. 반정규화 검토
   └─ 성능 요구사항에 따라 조정
```

### 5.2 체크리스트
```
□ 모든 테이블에 PK가 있는가?
□ FK 관계가 명확히 정의되었는가?
□ UNIQUE/CHECK 제약이 필요한 곳에 있는가?
□ 컬럼명이 일관된 규칙을 따르는가?
□ 데이터 타입/길이/기본값이 적절한가?
□ 불필요한 중복 데이터가 없는가?
□ NULL 허용 여부가 적절한가?
□ 인덱스 전략이 수립되었는가?
□ 조회/쓰기 패턴이 반영되었는가?
□ 삭제 정책(소프트/하드)과 이력 관리가 정해졌는가?
□ 향후 확장을 고려했는가?
```

---

## 6. 자주 하는 실수

| 실수 | 문제점 | 해결책 |
|------|--------|--------|
| 과도한 정규화 | 조인 증가로 성능 저하 | 적절한 반정규화 |
| PK 없는 테이블 | 데이터 무결성 보장 불가 | 반드시 PK 지정 |
| FK 없는 관계 | 고아 데이터 발생 | FK 제약 및 인덱스 설정 |
| 의미 없는 컬럼명 | 유지보수 어려움 | 명명 규칙 준수 |
| M:N 관계 방치 | 직접 구현 불가 | 중간 테이블 생성 |
| 모든 컬럼 VARCHAR | 타입 안정성 부족 | 적절한 타입 사용 |
| NULL 남발 | 의미 해석 어려움 | NULL 기준 정의 및 기본값 활용 |

---

## 7. 참고 자료

- **도서**: "데이터베이스 설계와 구축" - 이춘식
- **도서**: "The Data Model Resource Book" - Len Silverston
- **표기법**: IE(Information Engineering), UML, Barker
- **도구**: ERWin, DA#, MySQL Workbench, draw.io
