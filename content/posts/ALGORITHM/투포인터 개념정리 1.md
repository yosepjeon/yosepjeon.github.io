+++
title = "투 포인터(Two Pointers) 개념정리 1"
date = "2023-02-03"
author = "Yosep"
tags = ["algorithm", "two pointers"]
description = "Two Pointers 알고리즘에 대한 개념을 학습합니다."
weight = 1
+++

# 1. 투 포인터(Two Pointers)의 개념
## `두 개의 인덱스(포인터)를 적절히 움직이면서` 배열/리스트/문자열에서 O(N²)을 O(N)으로 줄여주는 패턴

### * 어떤 종류들이 있는가?
#### 정렬이 되어있지 않다면 정렬해주고 진행해야한다.
① 양끝형 Two Pointers (Opposite Direction)  
② 슬라이딩 윈도우형 Sliding Window (구간 유지)  
③ Read–Write형 (Fast–Slow, In-place Transformation)  

#### 각각 근본적으로 해결하는 문제 타입이 다르고 포인터 이동조건도 완전히 다르다.
## ① 양끝형 Two Pointers (Opposite Direction): left, right가 가리키는 두 원소만이 관심 대상
```bash
인덱스:   0    1    2    3    4    5
배열:    [ 1 | 2 | 4 | 7 | 11 | 15 ]

초기 상태
         L------------------------R
         left=0                 right=5

sum = arr[L] + arr[R] = 1 + 15

조건 비교:
- sum < target  → 더 크게 만들려면 left++
- sum > target  → 더 작게 만들려면 right--

예를 들어, 오른쪽을 줄인 다음:

         L-------------------R
         left=0            right=4

또 줄이면:

         L-------------R
         left=0      right=3

또는 왼쪽을 키우면:

              L--------R
              left=1 right=3

```
### 🧠 개념
- 정렬된 배열에서 사용
- `left = 0`, `right = n-1`에서 시작해서 서로 좁혀가는 방식
- 주로 "합", "차이", "쌍(pair)" 관련 문제를 해결

### 🎯 언제 쓰는가
- Two Sum
- 배열에서 특정 차이(K) 찾기
- 정렬된 배열에서 투 포인터로 특정 조건 만족하는 pair count하기
- Pair difference 
- Pair sum count 
- A+B=C 형태의 문제

## 🪄 핵심 템플릿
### 🧩 Java 템플릿
```java
int[] twoPointerOpposite(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int sum = nums[left] + nums[right];

        if (sum == target) {
            return new int[]{left, right}; // 한 쌍만 찾는 경우
        }

        if (sum < target) {
            left++;
        } else {
            right--;
        }
    }

    return new int[]{-1, -1};
}
```
### 🧩 Kotlin 템플릿
```kotlin
fun twoPointerOpposite(nums: IntArray, target: Int): IntArray {
    var left = 0
    var right = nums.size - 1

    while (left < right) {
        val sum = nums[left] + nums[right]

        when {
            sum == target -> return intArrayOf(left, right)
            sum < target -> left++
            else -> right--
        }
    }
    return intArrayOf(-1, -1)
}
```

## ② 슬라이딩 윈도우형 (Sliding Window): 연속된 구간 문제에서 거의 공식 템플릿
```bash
인덱스:   0    1    2    3    4    5
배열:    [ 1 | 2 | 3 | 1 | 2 | 3 ]
          ^                     ^
        left                  right
        (L)                    (R)

초기 상태:
L,R 둘 다 0에서 시작
배열:    [ 1 | 2 | 3 | 1 | 2 | 3 ]
          L
          R
윈도우: [0..0] = {1}

right 확장:
배열:    [ 1 | 2 | 3 | 1 | 2 | 3 ]
          L--------R
윈도우: [0..1] = {1,2}

right 확장:
배열:    [ 1 | 2 | 3 | 1 | 2 | 3 ]
          L-------------R
윈도우: [0..2] = {1,2,3}

조건 위반 시 (예: 합이 S를 넘음, 중복 발생 등)
→ left를 오른쪽으로 옮겨서 윈도우 축소:

배열:    [ 1 | 2 | 3 | 1 | 2 | 3 ]
               L--------R
윈도우:     [1..3] = {2,3,1}

조건 다시 만족하면
→ 현재 윈도우 [L..R]로 답 갱신
→ 다시 R++로 확장

```

### 🧠 개념
- 항상 `num[left..right]`라는 연속된 구간(window)을 유지
- `right`를 늘려 구간 확장 → 조건 초과 시 `left`를 줄여 값 감소시키기
- "연속된(subarray/substring)" + "조건 만족" 조합일 때 등장

### 🎯 언제 쓰는가
- 합이 K 이하/이상인 subarray
- 조건 만족 최소/최대 구간 길이
- 중복 없는 가장 긴 substring
- 최소 윈도우 substring (심화 문제)
- 연속된 구간에서 특정 조건 유지하기
- 합 ≤ K인 최대 길이 
- 합 ≥ K인 최소 길이 
- 중복 없는 substring 
- 최소 윈도우 substring 
- ‘연속된’이란 단어가 나오면 대부분 이쪽

## 🪄 핵심 템플릿
### 🧩 Java 템플릿 (합이 S 이하인 최대 길이)
```java
int slidingWindowMaxLength(int[] nums, int S) {
    int left = 0;
    int sum = 0;
    int maxLen = 0;

    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];

        while (sum > S) {
            sum -= nums[left];
            left++;
        }

        maxLen = Math.max(maxLen, right - left + 1);
    }

    return maxLen;
}
```

### 🧩 Kotlin 템플릿
```java
fun slidingWindowMaxLength(nums: IntArray, S: Int): Int {
    var left = 0
    var sum = 0
    var maxLen = 0

    for (right in nums.indices) {
        sum += nums[right]

        while (sum > S) {
            sum -= nums[left]
            left++
        }

        maxLen = maxOf(maxLen, right - left + 1)
    }

    return maxLen
}
```

## ③ Read–Write형 (Fast–Slow, In-place 변환): 배열을 제자리에서 정리/필터링 (중복 제거, 특정 값 제거 등)
```bash
예: 정렬된 배열에서 중복 제거
nums = [ 1 | 1 | 2 | 2 | 2 | 3 ]
         0   1   2   3   4   5
         ^   ^
        S   F
      slow fast

의미:
- slow(S): "지금까지 모은 유효한 결과의 마지막 위치"
- fast(F): "새로운 값을 읽는 위치"

초기:
S,F 모두 0 (첫 값 1은 무조건 유효)

1) fast=1
nums = [ 1 | 1 | 2 | 2 | 2 | 3 ]
         S   F
        0   1

nums[F] == nums[S] (1 == 1) → 새로운 값 아님 → S 그대로, F만++

2) fast=2
nums = [ 1 | 1 | 2 | 2 | 2 | 3 ]
         S       F
        0       2

nums[F] != nums[S] (2 != 1) → 새로운 값 등장
→ S를 한 칸 전진시키고, 그 자리에 새 값 넣기

S++        S
 |         v
nums = [ 1 | 2 | 2 | 2 | 2 | 3 ]
             F
결과 구간: [0..S] = {1,2}

3) fast 계속 진행
최종:
nums = [ 1 | 2 | 3 | ? | ? | ? ]
                 S
결과 길이 = S + 1 (여기서는 3)
```

### 🧠 개념
- 두 포인터가 모두 왼→오른쪽으로 이동
- `fast`는 읽기, `slow`는 쓰기
- 배열을 in-place로 변환할 때 많이 등장

### 🎯 언제 쓰는가
- 중복 제거 
- 특정 값 제거 
- 조건 만족하는 요소 모으기
- merge-like in-place 반환

## 🪄 핵심 템플릿(ex. 정럴배열 중복 제거)
### 🧩 Java 템플릿
```java
int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;

    int slow = 0;

    for (int fast = 1; fast < nums.length; fast++) {
        if (nums[fast] != nums[slow]) {
            slow++;
            nums[slow] = nums[fast];
        }
    }

    return slow + 1;
}
```

### 🧩 Kotlin 템플릿
```kotlin
fun removeDuplicates(nums: IntArray): Int {
    if (nums.isEmpty()) return 0

    var slow = 0

    for (fast in 1 until nums.size) {
        if (nums[fast] != nums[slow]) {
            slow++
            nums[slow] = nums[fast]
        }
    }

    return slow + 1
}
```

## ✔ 슬라이딩 윈도우는 투 포인터의 한 종류이지만, 투 포인터가 항상 슬라이딩 윈도우는 아니다.
| 관점     | 투 포인터 (Two Pointers)                          | 슬라이딩 윈도우 (Sliding Window) |
| ------ | --------------------------------------------- | ------------------------- |
| 포인터 방향 | 같은 방향 **또는 서로 반대**도 가능                        | 무조건 같은 방향                 |
| 윈도우 개념 | 항상 “구간(window)”을 유지하는 것은 아님                   | 항상 “구간(window)” 유지        |
| 적용 문제  | 정렬 배열에서 합/차 문제, in-place 문제 등 다양              | “연속된 구간” 문제에 특화           |
| 포인터 역할 | fast/slow로 다르게 움직이기도 하고, opposite pointer도 있음 | fast가 확장, slow가 축소        |

- <mark>슬라이딩 윈도우는 ‘연속된 구간을 유지하며 이동’</mark>이 핵심
- 투 포인터는 더 넓은 개념 (반대 방향에서 오는 포인터, 연속된 구간을 유지하지 않으며 이동도 포함)
